<html>

<head>
<title></title>
<link rel="stylesheet" href="../OmegaTech.css"></link>
<style>
</style>
</head>


<body>
<p>
The following is code written by Nistara Rhandawa to simulate  disease  propogation.
The questions is very interesting and the context important. But for making the code
faster, we can generally do this without knowing much about the code. Of course, it helps
if you are familiar with what the code is attempting to do, how the functions are written, etc.
And of course, often you are trying to make your own code more efficient, so you know these things.
However, we can use the following general steps to make code more efficient.
</p>

<p>
There are several files in the directory.
The <a href="setup.r">setup.r</a> file creates all of the input objects that are needed in the simulation.
The file <a href="simulation.r">simulation.r</a> runs the simulations.
However, the only important command is 
<pre>
nsims = 2 
nsteps = 1000
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
</pre>
The functions that are used in the simulation (and the creation of the inputs also)
are <a href="simulation-fxns.r-orig">simulation-fxns.r-orig</a>
and the more efficient versions in
<a href="simulation-fxns.r">simulation-fxns.r</a>.
The file SessionState.rda contains all the inputs to the simulation and 
allows us to avoid running createInputs.r which takes a minute or so.
</p>
<p>
In short, we are interested in 
making the functions in <a href="simulation-fxns.r">simulation-fxns.r</a>
more efficient when we run 
<pre>
nsims = 2 
nsteps = 1000
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
</pre>
</p>
<p>
We could try to make the code in createInputs.r and the associated functions more efficient,
but these are only run once. So it is not clear this is worth the effort.
</p>

<p>
The results of changing the functions from 
<a href="simulation-fxns.r-orig">simulation-fxns.r-orig</a>
to <a href="simulation-fxns.r">simulation-fxns.r</a>
change the run time of the simulations from 23.16 seconds to 12.0 seconds
on an MacbookPro running OSX. We should report the version
of R, the amount of RAM, what else was running and so on. These are important and often
make a difference.  See sessionInfo() for just the R configuration.
<pre>
R Under development (unstable) (2016-06-30 r70858)
Platform: x86_64-apple-darwin15.2.0 (64-bit)
Running under: OS X El Capitan 10.11.6

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] parallel  stats     graphics  grDevices datasets  utils    
[7] methods   base     

other attached packages:
[1] igraph_1.0.1

loaded via a namespace (and not attached):
[1] magrittr_1.5
</pre>
</p>

<p>
If you want to skip to the punch line, you can compare the two files
simulation-fxn.r-orig  and simulation-fxn.r and see the differences.
Use the UNIX command diff, or source() them into separate R environments and compare manually or programmatically. See <a href="#Summary">below</a> for a summary of what we changed.
</p>

<h2>Step I: Profiling</h2>
We start with the original functions in simulation-fxns.r-orig.  We started by adapting these
functions to avoid any use of global variables and explicitly passing all of the input objects
directly through the different functions. This actually saves a small amount of run-time as
the R interpreter doesn't have to search along the R search() path for these variables.
This is a very small amount of time in this case, but it is a general point.
<pre>
Never Use Global Variables!
</pre>

<p>
So the simulation-fxns.r-orig are our initial baseline.
We first time how long our 2 simulations take.
<pre>
source("simulations-fxns.r-orig")
nsims = 2 
nsteps = 1000
system.time({sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)})
   user  system elapsed 
 22.902   0.129  23.160 
</pre>
Of course, your time will be different and indeed, if I run this again, I will get a different time.
We have to decide what it is a reasonable number of simulations and steps to get a reasonable
estimate of how long the code takes.  And we want to see how the run time varies as we change
the number of simulations and steps. Specifically we want to see if the code is linear, quadratic, ...
</p>

<p>
Is 23 seconds fast enough?  If we want to run 1000 simulations with 1000 steps
(based on power calculations, etc.), this would take about 3 hours.  
If we are happy with this, we are done and don't need to improve our code.
If we need to run 100,000 simulations (with 1000 steps), this will take about 319 hours or
13 days. This is too long. So let's try to make this code more efficient.
</p>

<h2>Profiling</h2>
<p>
We start by profiling the code to find those functions which the code spends the most amount of time
in.
We use Rprof() for this (or lineprof which uses Rprof)
<pre>
Rprof("prof1")
tm.orig = system.time({sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)})
Rprof(NULL)
</pre>
We now read the results of the profiling and see where the "offending" functions are:
<pre>
summaryRprof("prof1")$by.self
                self.time self.pct total.time total.pct
"match"             11.28    53.11      13.64     64.22
"[[.data.frame"      1.58     7.44       5.06     23.82
"%in%"               1.54     7.25      14.98     70.53
"FUN"                1.42     6.69      21.24    100.00
"rbinom"             1.00     4.71       1.00      4.71
"<Anonymous>"        0.92     4.33       1.46      6.87
"$.data.frame"       0.62     2.92       6.26     29.47
"$"                  0.60     2.82       6.86     32.30
"[["                 0.58     2.73       5.64     26.55
"sys.call"           0.40     1.88       0.40      1.88
"lapply"             0.28     1.32      21.24    100.00
".subset2"           0.24     1.13       0.24      1.13
"all"                0.24     1.13       0.24      1.13
"names"              0.14     0.66       0.14      0.66
"mapply"             0.10     0.47       0.44      2.07
"cat"                0.10     0.47       0.10      0.47
"sum"                0.06     0.28       0.06      0.28
"*"                  0.04     0.19       0.04      0.19
"is.matrix"          0.04     0.19       0.04      0.19
"nargs"              0.04     0.19       0.04      0.19
"as.data.frame"      0.02     0.09       0.02      0.09
</pre>

What does this tell us?
The function match() is being called and this takes up over 50% of the overall time.
The [[.data.frame is the mechanism used for <code>dataFrame[[ index ]]</code> and also 
<code>dataFrame$varName</code>.
And if you know how <code>dataFrame$varName</code> works (by looking at the $.data.frame
function), it calls [[.data.frame and also possibly pmatch.
Also, %in% is the third most expensive function. And again, with some knowledge, 
%in% calls match(). So our time in match() <i>may</i> be due to %in%.
We need to determine this.
</p>
<p>
Does our simulation code call match()?  [[.data.frame?  %in%? 
And what is FUN?
</p>
<p>
We can search for these in our R code files, e.g., from the UNIX shell
<pre>
grep '%in%' simulation-fxns.r-orig
</pre>
Here is the output:
<pre>
        df = edges[ edges$from %in% from, ]
    seed_row = which(df$name %in% nd)
                vert_info$name %in% neigh_name ]
    I = vert_info$I[ vert_info$name %in% comp$name ]
    local_foi = l_in_node$l_in_node[ l_in_node$name %in% nodes ]
</pre>
So there are 5 places in the code.
Unfortunately we can't see which functions these are in, or even if these functions are called.
But we know %in% is in our code.
match() is not in our code.
And [[.data.frame is hard to tell as the R interpreter expands this from
df$var and df[[position]].
</p>
<p>
So now we don't know whether the time spent in match() is due to our calls to  %in% 
(which we had to know %in% called match) or is due to other calls.
We also don't know how many times match was called. If it is once, then this is a long
time. If it it is 1 million times, then less of a bottleneck. However, we still want to reduce
the time in match(). 
match() is a function that comes in base R and is used a lot. It is pretty fast - implemented in C -
so we are unlikely to make it faster.  However, it is also quite general which gives it its power
and flexibility, but maybe this is overkill for our needs. We may be able to avoid some of the
calls to match().
First we need to find out a) how many calls there are, and b) where are they coming from,
i.e. what functions are calling them.
How many are coming from %in% in our code? from [[.data.frame? direct calls to match()?
</p>

<h2>Counting the Calls</h2>
<p>
We can look at the code and see how many references there are to %in%.
But that doesn't tell us how often that line of code is actually evaluated/called.
Also, we don't have any explicit/direct calls to match() so we can't directly count the number of 
calls to match() in the code.
More importantly, we want the number of actual calls, not the lines of code.
We use trace() to monitor every call to a function.
We pass trace() the function to be monitored and either
a function or an unevaluated expression (a language object)
to call each time that monitored function is called
<pre>
trace(match, aFunction, print = FALSE) 
trace(match, expression, print = FALSE)
</pre>
In our case, we want to update a counter for the number of calls to match.
<pre>
matchCtr = 0
trace(match, quote(matchCtr <<- matchCtr + 1), print = FALSE)
</pre>
(There is a nicer way to do this below.)
Then we run the simulations again.
<pre>
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
</pre>
This is a little slower as we are executing this extra line of code in each call to match()
and we are updating a global variable. But it isn't too bad.
<p>
Now we look at the value of matchCtr and see it is 708906.
We should also have traced %in% and [[.data.frame.
We can use a separate global variable for each of these, or we could use a vector for the tree of them and update the corresponding element.
Rather than using a global variable, we'll use a closure.
See the code in traceCalls.R, specifically genCounter().
<pre>
source('../traceCalls.R')
matchCtr = genCounter()
trace(match, matchCtr, print = FALSE)
inCtr = genCounter()
trace(match, `%in%`, print = FALSE)
subDataFrame = genCounter()
trace(match, `[[.data.frame`, print = FALSE)
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
</pre>
</p>

<h2>Finding What Calls What</h2>
We want to find out what functions call match(), %in%, etc.
<pre>
source("../traceCalls.R")
k = genCallCollector2()
kol = k$collect
trace(match, quote(kol("match")), print = FALSE)
trace(`%in%`, quote(kol("%in%")), print = FALSE)
trace(`[[.data.frame`, quote(kol("[[.data.frame")), print = FALSE)
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
</pre>
<p>
After this code has run, we can collect the system calls for the three functions
with the raw
<pre>
calls = k$ans()
</pre>

We get the number of calls to these (as before)
with
<pre>
sapply(calls, length)
[[.data.frame          %in%         match
       570316        708740        708906
</pre>

We'll focus on match() since this was the function that dominated the profiling.
We'll look at the call stack and see the different ways match() is called and how often.
We'll collapse each call stack into a string with the names of the functions being called as the contents
<pre>
m = calls$match
foo = lapply(m, function(x) as.character(sapply(x, `[[`, 1)))
bar = sapply(foo, function(x) paste(x[1:(length(x) - 5)], collapse = "->"))
</pre>
We exclude the last 5 elements which are related to the tracing itself.
This takes several minutes. Then we end up with something similar to 
<pre>
table(bar)
                                                    FUN->foi_fxn->data.frame->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                     54 
                                                        FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->`%in%`->match 
                                                                                                                                     54 
                       FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->as.data.frame.vector->structure->`%in%`->match 
                                                                                                                                     54 
                               FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->as.data.frame.vector->structure->match 
                                                                                                                                     54 
                                 FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                     54 
                                               FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match 
                                                                                                                                     54 
   FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match->mode->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                     54 
                 FUN->foi_fxn->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match->mode->deparse->`%in%`->match 
                                                                                                                                     54 
                                                             FUN->data.frame->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                     56 
                                                                 FUN->data.frame->as.data.frame->as.data.frame.character->`%in%`->match 
                                                                                                                                     56 
                                FUN->data.frame->as.data.frame->as.data.frame.character->as.data.frame.vector->structure->`%in%`->match 
                                                                                                                                     56 
                                        FUN->data.frame->as.data.frame->as.data.frame.character->as.data.frame.vector->structure->match 
                                                                                                                                     56 
                                          FUN->data.frame->as.data.frame->as.data.frame.character->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                     56 
                                                        FUN->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match 
                                                                                                                                     56 
            FUN->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match->mode->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                     56 
                          FUN->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match->mode->deparse->`%in%`->match 
                                                                                                                                     56 
                              FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                     56 
                                            FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->`%in%`->match 
                                                                                                                                     56 
FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->`%in%`->match->mode->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                     56 
              FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->`%in%`->match->mode->deparse->`%in%`->match 
                                                                                                                                     56 
                                                        FUN->data.frame->as.data.frame->as.data.frame.numeric->structure->`%in%`->match 
                                                                                                                                     56 
                                                                FUN->data.frame->as.data.frame->as.data.frame.numeric->structure->match 
                                                                                                                                     56 
                                                        FUN->do.call->lapply->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                    112 
                                                                 FUN->mapply->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                    112 
                                                                FUN->foi_fxn->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                    270 
                                                                         FUN->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                    336 
                                                                                               FUN->foi_fxn->lapply->FUN->`%in%`->match 
                                                                                                                                 137484 
                                    FUN->foi_fxn->lapply->FUN->`%in%`->match->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                 206766 
                                                   FUN->foi_fxn->lapply->FUN->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                 362610 
</pre>
We are really only interested in the last 3 as they are called  137K, 206K an 362K times. The others are not called very often.
<p>
The call stack
<pre>
FUN->foi_fxn->lapply->FUN->`%in%`->match 
</pre>
corresponds to a direct call to %in% in our code.
The other two are implicit calls to match.
The stack
<pre>
FUN->foi_fxn->lapply->FUN->`%in%`->match->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
</pre>
has two calls to match and the first is the one above and the second is due to using the $ to access an element 
of a data frame which calls [[.data.frame which calls match.
This is the same for the third call stack
<pre>
FUN->foi_fxn->lapply->FUN->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
</pre>
<p>
Let's view the code for [[.data.frame
<pre>
`[[.data.frame`
function (x, ..., exact = TRUE) 
{
    na <- nargs() - (!missing(exact))
    if (!all(names(sys.call()) %in% c("", "exact"))) 
        warning("named arguments other than 'exact' are discouraged")
    if (na < 3L) 
        (function(x, i, exact) if (is.matrix(i)) 
            as.matrix(x)[[i]]
        else .subset2(x, i, exact = exact))(x, ..., exact = exact)
    else {
        col <- .subset2(x, ..2, exact = exact)
        i <- if (is.character(..1)) 
            pmatch(..1, row.names(x), duplicates.ok = TRUE)
        else ..1
        col[[i, exact = exact]]
    }
}
<bytecode: 0x7f8c8cba1ca8>
<environment: namespace:base>
</pre>
We see the explicit call to %in% which is for checking the names of the arguments.
The right hand side of the %in% is just two elements so this should be quick.
However, this is called a lot. So we may want to try to avoid it.

<p>
So we have two strategies to pursue for trying to reduce the time spent in match related to being called from %in%.
<ol>
<li> Avoid the explicit call to %in% in our code
<li> Avoid using dataframe$var in our code
</ol>
Where do these two occur?
We have a good idea from the call stack to help us rather than just looking through code that may not even be used in the simulation.
Looking at 
<pre>
FUN->foi_fxn->lapply->FUN->`%in%`->match 
</pre>
we see that foi_fxn calls lapply() and that function being applied (FUN) is the one that calls %in%.
Looking at the definition of foi_fxn(), we see the call to lapply as
<pre>
    l_ji  = lapply(j_out, l_ji_fxn, l_in_node)
</pre>
and so we know to look in l_ji_fxn.
(If we had written the code, we would probably know which function was called. But we can find it regardless.
We could also use debug() to stop in %in% but then we would probably have a lot of irrelevant stops.
We could use trace() to conditionally stop (calling recover()) when the call stack was FUN-&gt;%in%.
We only want to look at the first one so we won't continue the computations after this.)

<p>
l_ji_fxn is defined as
<pre>
l_ji_fxn = function(j_out, l_in_node){
    nodes = j_out$name
    sigmaProp_by_tau = j_out$sigmaProp_by_tau
    local_foi = l_in_node$l_in_node[ l_in_node$name %in% nodes ]
    df = sigmaProp_by_tau * local_foi
    df = sum(df, na.rm = TRUE)
    return(df)
}
</pre>
We see the call to %in% in the third line of the body of the function
<pre>
l_in_node$l_in_node[ l_in_node$name %in% nodes ]
</pre>
Let's arrange to stop in l_ji_fxn and see what the values of these objects are:
<pre>
debug(l_ji_fxn)
</pre>

<pre>
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
-------------------------------------------------------
******** Simulation  1 
			Timestep: 1/1000debugging in: FUN(X[[i]], ...)
debug at simulation-fxns.r-orig#249: {
    nodes = j_out$name
    sigmaProp_by_tau = j_out$sigmaProp_by_tau
    local_foi = l_in_node$l_in_node[l_in_node$name %in% nodes]
    df = sigmaProp_by_tau * local_foi
    df = sum(df, na.rm = TRUE)
    return(df)
}
Browse[2]> ls()
[1] "j_out"     "l_in_node"
Browse[2]> n
debug at simulation-fxns.r-orig#250: nodes = j_out$name
Browse[2]> 
debug at simulation-fxns.r-orig#251: sigmaProp_by_tau = j_out$sigmaProp_by_tau
Browse[2]> 
debug at simulation-fxns.r-orig#252: local_foi = l_in_node$l_in_node[l_in_node$name %in% nodes]
Browse[2]> class(l_in_node$l_in_node)
[1] "numeric"
Browse[2]> length(l_in_node$l_in_node)
[1] 1273
Browse[2]> names(l_in_node$l_in_node)
NULL
Browse[2]> class(nodes)
[1] "character"
Browse[2]> length(nodes)
[1] 2
Browse[2]> nodes
[1] "4"  "12"
Browse[2]> l_in_node$name
   [1] "0"    "1"    "2"    "3"    "4"    "5"    "6"    "9"    "11"  
  [10] "12"   "13"   "15"   "16"   "17"   "18"   "20"   "21"   "22"  
  [19] "23"   "24"   "25"   "27"   "28"   "29"   "30"   "32"   "33"  
  [28] "34"   "36"   "38"   "40"   "41"   "42"   "43"   "44"   "45"  
  [37] "46"   "48"   "49"   "51"   "52"   "53"   "54"   "55"   "57"  
  [46] "58"   "60"   "61"   "62"   "64"   "65"   "66"   "67"   "69"  
  [55] "71"   "72"   "73"   "74"   "75"   "78"   "79"   "81"   "82"  
  [64] "83"   "84"   "85"   "86"   "88"   "89"   "90"   "91"   "92"  
  [73] "93"   "94"   "95"   "97"   "98"   "99"   "100"  "101"  "102" 
  [82] "104"  "106"  "107"  "108"  "109"  "110"  "111"  "112"  "113" 
  [91] "114"  "115"  "116"  "117"  "118"  "119"  "120"  "121"  "122" 
 [100] "124"  "126"  "127"  "128"  "129"  "130"  "131"  "133"  "134" 
 [109] "135"  "136"  "137"  "138"  "139"  "140"  "141"  "142"  "143" 
 [118] "144"  "145"  "146"  "147"  "148"  "149"  "150"  "151"  "152" 
 [127] "153"  "154"  "155"  "156"  "157"  "158"  "159"  "160"  "162" 
 [136] "163"  "164"  "165"  "166"  "167"  "169"  "170"  "171"  "172" 
 [145] "173"  "174"  "175"  "176"  "177"  "178"  "179"  "180"  "181" 
 [154] "182"  "183"  "184"  "185"  "186"  "188"  "189"  "191"  "193" 
 [163] "194"  "195"  "196"  "198"  "199"  "200"  "201"  "205"  "206" 
 [172] "207"  "208"  "209"  "210"  "211"  "212"  "213"  "214"  "215" 
 [181] "216"  "217"  "219"  "220"  "223"  "224"  "227"  "229"  "230" 
 [190] "231"  "233"  "236"  "237"  "239"  "240"  "241"  "242"  "243" 
 [199] "244"  "245"  "246"  "248"  "249"  "250"  "251"  "252"  "254" 
 [208] "256"  "257"  "258"  "259"  "261"  "262"  "263"  "264"  "265" 
 [217] "266"  "267"  "268"  "269"  "270"  "271"  "272"  "273"  "274" 
 [226] "275"  "276"  "278"  "279"  "280"  "281"  "283"  "285"  "286" 
 [235] "287"  "289"  "290"  "291"  "292"  "294"  "297"  "298"  "301" 
 [244] "303"  "305"  "307"  "308"  "309"  "310"  "311"  "312"  "314" 
 [253] "315"  "316"  "318"  "319"  "320"  "321"  "327"  "328"  "329" 
 [262] "331"  "335"  "336"  "337"  "338"  "339"  "340"  "342"  "343" 
 [271] "344"  "345"  "346"  "347"  "348"  "349"  "350"  "351"  "353" 
 [280] "354"  "358"  "359"  "360"  "361"  "364"  "365"  "366"  "367" 
 [289] "368"  "369"  "370"  "371"  "372"  "375"  "376"  "378"  "379" 
 [298] "380"  "381"  "382"  "384"  "386"  "387"  "388"  "389"  "391" 
 [307] "395"  "396"  "397"  "399"  "400"  "401"  "402"  "405"  "406" 
 [316] "407"  "408"  "409"  "411"  "412"  "413"  "414"  "415"  "416" 
 [325] "418"  "419"  "420"  "421"  "422"  "423"  "424"  "426"  "427" 
 [334] "428"  "429"  "430"  "431"  "432"  "433"  "434"  "435"  "436" 
 [343] "437"  "438"  "439"  "440"  "441"  "442"  "443"  "445"  "446" 
 [352] "447"  "449"  "452"  "453"  "454"  "455"  "456"  "457"  "458" 
 [361] "460"  "461"  "462"  "463"  "464"  "465"  "467"  "468"  "469" 
 [370] "470"  "471"  "472"  "474"  "475"  "476"  "477"  "479"  "483" 
 [379] "484"  "486"  "487"  "488"  "489"  "490"  "491"  "493"  "495" 
 [388] "496"  "497"  "499"  "500"  "501"  "504"  "505"  "506"  "507" 
 [397] "508"  "509"  "510"  "511"  "512"  "513"  "514"  "515"  "516" 
 [406] "518"  "520"  "521"  "522"  "523"  "524"  "526"  "527"  "530" 
 [415] "531"  "532"  "533"  "534"  "535"  "536"  "537"  "539"  "540" 
 [424] "542"  "543"  "544"  "546"  "547"  "548"  "549"  "550"  "551" 
 [433] "552"  "553"  "555"  "556"  "557"  "559"  "560"  "561"  "562" 
 [442] "564"  "565"  "566"  "567"  "568"  "569"  "570"  "571"  "572" 
 [451] "573"  "574"  "575"  "576"  "577"  "578"  "580"  "581"  "583" 
 [460] "584"  "585"  "588"  "589"  "590"  "591"  "592"  "598"  "599" 
 [469] "602"  "603"  "604"  "605"  "607"  "610"  "611"  "612"  "614" 
 [478] "615"  "617"  "618"  "619"  "620"  "621"  "622"  "623"  "624" 
 [487] "625"  "626"  "627"  "629"  "630"  "633"  "634"  "635"  "636" 
 [496] "637"  "639"  "641"  "642"  "643"  "644"  "645"  "647"  "648" 
 [505] "649"  "650"  "651"  "652"  "653"  "655"  "656"  "658"  "659" 
 [514] "660"  "661"  "662"  "663"  "664"  "665"  "666"  "667"  "668" 
 [523] "669"  "671"  "673"  "675"  "676"  "677"  "678"  "679"  "681" 
 [532] "683"  "684"  "685"  "686"  "687"  "690"  "691"  "692"  "695" 
 [541] "696"  "697"  "698"  "699"  "701"  "702"  "703"  "704"  "705" 
 [550] "706"  "707"  "708"  "709"  "710"  "711"  "712"  "713"  "714" 
 [559] "715"  "716"  "717"  "718"  "720"  "721"  "724"  "725"  "726" 
 [568] "727"  "729"  "732"  "733"  "734"  "736"  "738"  "739"  "740" 
 [577] "741"  "742"  "743"  "744"  "745"  "746"  "747"  "748"  "749" 
 [586] "751"  "752"  "755"  "756"  "757"  "759"  "760"  "761"  "762" 
 [595] "763"  "764"  "765"  "766"  "767"  "768"  "769"  "770"  "771" 
 [604] "772"  "773"  "774"  "775"  "776"  "777"  "778"  "779"  "780" 
 [613] "781"  "782"  "783"  "784"  "785"  "786"  "787"  "788"  "789" 
 [622] "790"  "791"  "792"  "793"  "795"  "796"  "797"  "798"  "800" 
 [631] "802"  "803"  "804"  "805"  "808"  "809"  "810"  "811"  "812" 
 [640] "813"  "814"  "819"  "820"  "821"  "822"  "824"  "826"  "827" 
 [649] "828"  "829"  "831"  "833"  "834"  "835"  "836"  "837"  "838" 
 [658] "840"  "841"  "842"  "843"  "846"  "847"  "849"  "850"  "851" 
 [667] "852"  "854"  "856"  "858"  "860"  "861"  "862"  "863"  "864" 
 [676] "865"  "866"  "867"  "868"  "869"  "870"  "871"  "872"  "874" 
 [685] "876"  "877"  "878"  "879"  "880"  "881"  "882"  "884"  "885" 
 [694] "889"  "890"  "892"  "893"  "895"  "897"  "898"  "901"  "902" 
 [703] "903"  "904"  "906"  "907"  "908"  "909"  "910"  "911"  "912" 
 [712] "913"  "916"  "917"  "918"  "919"  "921"  "922"  "926"  "928" 
 [721] "929"  "930"  "932"  "933"  "934"  "935"  "936"  "937"  "938" 
 [730] "939"  "940"  "941"  "942"  "943"  "944"  "945"  "946"  "947" 
 [739] "948"  "949"  "950"  "951"  "952"  "953"  "954"  "957"  "958" 
 [748] "959"  "960"  "961"  "962"  "963"  "964"  "966"  "967"  "968" 
 [757] "970"  "972"  "973"  "974"  "976"  "977"  "978"  "979"  "980" 
 [766] "981"  "982"  "983"  "984"  "985"  "986"  "987"  "990"  "991" 
 [775] "992"  "993"  "995"  "996"  "999"  "1000" "1001" "1002" "1003"
 [784] "1005" "1006" "1007" "1008" "1009" "1010" "1011" "1012" "1013"
 [793] "1016" "1017" "1018" "1020" "1021" "1022" "1023" "1024" "1026"
 [802] "1027" "1030" "1031" "1032" "1033" "1034" "1035" "1036" "1037"
 [811] "1038" "1039" "1040" "1041" "1042" "1043" "1044" "1045" "1046"
 [820] "1047" "1050" "1051" "1052" "1054" "1055" "1056" "1058" "1060"
 [829] "1062" "1063" "1064" "1065" "1066" "1067" "1069" "1070" "1071"
 [838] "1072" "1073" "1074" "1075" "1076" "1077" "1078" "1079" "1080"
 [847] "1081" "1082" "1083" "1084" "1085" "1086" "1088" "1089" "1091"
 [856] "1092" "1093" "1095" "1096" "1097" "1098" "1100" "1101" "1102"
 [865] "1103" "1104" "1105" "1106" "1107" "1108" "1109" "1110" "1112"
 [874] "1113" "1115" "1118" "1120" "1121" "1122" "1126" "1127" "1130"
 [883] "1131" "1133" "1134" "1135" "1136" "1137" "1138" "1139" "1141"
 [892] "1142" "1144" "1145" "1146" "1147" "1148" "1149" "1150" "1151"
 [901] "1152" "1153" "1154" "1155" "1156" "1157" "1159" "1160" "1161"
 [910] "1163" "1165" "1166" "1167" "1168" "1169" "1170" "1172" "1173"
 [919] "1174" "1175" "1176" "1177" "1180" "1181" "1182" "1183" "1185"
 [928] "1186" "1188" "1189" "1190" "1191" "1192" "1193" "1194" "1195"
 [937] "1196" "1197" "1199" "1200" "1201" "1204" "1205" "1207" "1208"
 [946] "1209" "1210" "1211" "1212" "1213" "1215" "1216" "1217" "1218"
 [955] "1219" "1220" "1221" "1222" "1223" "1225" "1226" "1227" "1229"
 [964] "1230" "1231" "1234" "1235" "1236" "1238" "1239" "1240" "1241"
 [973] "1242" "1243" "1246" "1248" "1249" "1250" "1253" "1254" "1255"
 [982] "1256" "1257" "1258" "1259" "1260" "1261" "1262" "1263" "1264"
 [991] "1265" "1266" "1268" "1269" "1270" "1271" "1272" "1273" "1274"
[1000] "1275" "1276" "1278" "1279" "1280" "1281" "1282" "1283" "1284"
[1009] "1285" "1286" "1287" "1290" "1291" "1292" "1293" "1294" "1296"
[1018] "1297" "1298" "1299" "1301" "1302" "1303" "1304" "1305" "1306"
[1027] "1307" "1308" "1309" "1310" "1311" "1312" "1313" "1314" "1315"
[1036] "1317" "1318" "1319" "1320" "1321" "1322" "1324" "1325" "1326"
[1045] "1328" "1330" "1331" "1332" "1333" "1334" "1335" "1336" "1337"
[1054] "1338" "1339" "1340" "1341" "1342" "1343" "1344" "1345" "1346"
[1063] "1348" "1349" "1350" "1351" "1352" "1353" "1354" "1355" "1356"
[1072] "1357" "1359" "1360" "1361" "1362" "1364" "1365" "1366" "1367"
[1081] "1368" "1369" "1370" "1371" "1372" "1373" "1374" "1375" "1376"
[1090] "1377" "1378" "1380" "1381" "1382" "1383" "1386" "1387" "1388"
[1099] "1389" "1390" "1391" "1392" "1393" "1394" "1395" "1396" "1397"
[1108] "1398" "1400" "1401" "1402" "1403" "1404" "1405" "1406" "1407"
[1117] "1408" "1409" "1410" "1411" "1412" "1413" "1414" "1415" "1416"
[1126] "1417" "1418" "1419" "1420" "1421" "1422" "1423" "1424" "1425"
[1135] "1426" "1427" "1428" "1429" "1430" "1433" "1434" "1435" "1436"
[1144] "1437" "1438" "1439" "1440" "1441" "1442" "1443" "1444" "1445"
[1153] "1446" "1447" "1448" "1449" "1450" "1451" "1454" "1455" "1457"
[1162] "1458" "1459" "1460" "1461" "1462" "1463" "1464" "1465" "1466"
[1171] "1467" "1468" "1469" "1470" "1471" "1472" "1473" "1475" "1476"
[1180] "1477" "1478" "1479" "1480" "1481" "1482" "1483" "1484" "1485"
[1189] "1486" "1487" "1489" "1490" "1492" "1493" "1494" "1495" "1497"
[1198] "1499" "1500" "1501" "1503" "1505" "1506" "1507" "1508" "1509"
[1207] "1510" "1511" "1512" "1513" "1514" "1515" "1516" "1517" "1518"
[1216] "1520" "1521" "1522" "1523" "1524" "1525" "1526" "1527" "1528"
[1225] "1529" "1530" "1531" "1532" "1534" "1535" "1536" "1537" "1538"
[1234] "1539" "1540" "1544" "1545" "1546" "1547" "1550" "1551" "1553"
[1243] "1554" "1555" "1556" "1560" "1561" "1565" "1568" "1569" "1570"
[1252] "1571" "1572" "1573" "1574" "1575" "1577" "1580" "1583" "1584"
[1261] "1586" "1587" "1588" "1589" "1594" "1595" "1596" "1597" "1598"
[1270] "1599" "1601" "1603" "1605"
</pre>
Note that values in l_in_node$name are not contiguous. For example, there are no 7, 8 or 10 values.
So the l_in_node$name %in% nodes seems reasonable. 
However, we are checking all 1273 elements in l_in_node$name against just  two elements in nodes.
There is a lot of unnecessary computation here. We can invert this and match nodes into l_in_node$name and then subset accordingly.
Basically,
<pre>
match(nodes, l_in_node$name)
which(l_in_node$name %in% nodes)
</pre>
give the same result. If we have to concern ourselves with one or more elements of nodes not being in l_in_node$name and the call to match() yielding NAs,
we can use
<pre>
match(nodes, l_in_node$name, 0)
</pre>
which says to return 0 of there is no match for an element in nodes.
So we can use
<pre>
l_in_node$l_in_node [ match(nodes, l_in_node$name) ]
</pre>
Does this give us the same results?
<pre>
identical(l_in_node$l_in_node [ match(nodes, l_in_node$name) ],  l_in_node$l_in_node[l_in_node$name %in% nodes])
</pre>
Is this faster?
<pre>
system.time(replicate(10000, l_in_node$l_in_node [ match(nodes, l_in_node$name) ]))
   user  system elapsed 
  0.399   0.000   0.399 
Browse[2]> system.time(replicate(10000, l_in_node$l_in_node[l_in_node$name %in% nodes]))
   user  system elapsed 
  1.020   0.000   1.021 
</pre>
So yes, a little over 2 times faster.
<p>
Another approach is, if the vector l_in_node$l_in_node had names corresponding to l_in_node$name, we could used named subsetting rather than %in%.
<pre>
tmp = l_in_node$l_in_node
names(tmp) = l_in_node$name
identical(tmp[ nodes ], l_in_node$l_in_node[l_in_node$name %in% nodes])
</pre> 
These are not identical.  The first has names and the second doesn't. So we want to use all.equal() instead. But the values are the same.

<p>
How fast is named subsetting relative to the direct call to match().
<pre>
system.time(replicate(10000, tmp[nodes]))
   user  system elapsed 
  0.652   0.000   0.652 
system.time(replicate(10000, l_in_node$l_in_node [ match(nodes, l_in_node$name) ]))
   user  system elapsed 
  0.839   0.000   0.840 
system.time(replicate(10000, l_in_node$l_in_node[l_in_node$name %in% nodes]))
   user  system elapsed 
  1.207   0.000   1.208 
</pre>
Note that the timing for the match() approach doubled.  This indicates that something else may be happening on the machine and that are numbers
aren't absolute.  This is why we need to compare two approaches at the same time, i.e. under hopefully the same situation.
And we shoould repeat the entire measurement process for each multiple times to get the standard deviation.
<p>
Using names appears to be a little faster.
One can argue that we have also eliminate the need to extract the l_in_node and name from the l_in_node object,
i.e. <code>l_in_node$l_in_node [ match(nodes, l_in_node$name) ]</code>.  This is true and an issue.
However, we can also change the structure of the top-level l_in_node not to be a data.frame but just a named numeric vector.
If we do this in functions that call this function, then this avoids the need for l_in_node$l_in_node and l_in_node$name.
So the timing comparisons would be valid.

<p>
Before we consider making any changes, let's examine other calls to l_ji_fxn. Perhaps they are quite different.
We continue and each time l_ji_fxn is called, we query the length and class of nodes and l_in_node.
Alternatively, we can trace this function and stop if these deviate from what we expect.
<pre>
undebug(l_ji_fxn)
trace(l_ji_fxn, quote(if(! all(nodes %in% l_in_node$name )) stop("unexpected")), at = 4, print = FALSE)
</pre>
When we run our simulations,
<pre>
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
</pre>
we don't stop and our expectations are confirmed.

<p>
We could make the more extensive changes of using the named vector which involves changing at least two functions.
We'll first use the explicit match(nodes, l_in_node$name) approach as this requires only changing l_ji_fxn.
We define this modified function in <a href="l_ji_fxn_match.r">l_ji_fxn_match.r</a> and source it into our R session:
<pre>
source("l_ji_fxn_match.r")
</pre>
Let's profile our simulation again.
<pre>
Rprof("prof")
tm.match = system.time(sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out))
Rprof(NULL)
</pre>
The results are
<pre>
summaryRprof("prof")$by.self
                self.time self.pct total.time total.pct
"match"                5.98    42.47       8.10     57.53
"[[.data.frame"        1.26     8.95       4.06     28.84
"FUN"                  1.16     8.24      14.08    100.00
"%in%"                 0.78     5.54       6.08     43.18
"$.data.frame"         0.74     5.26       5.28     37.50
"<Anonymous>"          0.74     5.26       1.22      8.66
"$"                    0.70     4.97       5.98     42.47
"lapply"               0.52     3.69      14.08    100.00
"[["                   0.48     3.41       4.54     32.24
"sys.call"             0.38     2.70       0.38      2.70
"rbinom"               0.36     2.56       0.36      2.56
".subset2"             0.18     1.28       0.18      1.28
"all"                  0.14     0.99       0.14      0.99
"is.matrix"            0.14     0.99       0.14      0.99
"names"                0.14     0.99       0.14      0.99
"do.call"              0.12     0.85       0.74      5.26
"mapply"               0.08     0.57       0.32      2.27
"nargs"                0.06     0.43       0.06      0.43
"sum"                  0.06     0.43       0.06      0.43
".row_names_info"      0.04     0.28       0.04      0.28
"*"                    0.02     0.14       0.02      0.14
</pre>

The times are very different from our original profiling above as this was done on a faster machine with a different operating system (Linux). 
However, the percentages are comparable across the two. And here match() takes 42% of the time in comparison with 53% previously.
Note that these are samples so the results are subject to randonmess, but they are pretty stable.
<p>
The times for the original code and this small change to l_ji_fxn are very different with the original code being about 10% slower.
<pre>
tm.orig/tm.match
    user   system  elapsed 
1.097301 0.000000 1.097153 
</pre>

<p>
Let's use named vectors to replace the l_in_node data frame with separate columns for the node names and values.
We change l_ji_fxn() in the file l_ji_fxn_named_vector.r.
What calls l_ji_fxn(). During our sleuthing to find what called %in%, we know 
foi_fxn() calls l_ji_fxn(). Are there other functions that call l_ji_fxn()?
We can search the code in a text editor.
Alternatively, we can use the codetools package.
We'll source the functions into a separate environment, find the functions and then
query the functions they call with findGlobals()
<pre>
source("simulation-fxns.r-orig", e)
e = new.env()
library(codetools)
funs = lapply(ls(e), function(f) findGlobals(get(f, e)))
names(funs) = ls(e)
</pre>
Which of these refere to l_ji_fxn
<pre>
   add_sigmas_fxn       comp2_i_fxn     comp2_sub_fxn effective_pop_fxn 
            FALSE             FALSE             FALSE             FALSE 
  effective_pop_I  effective_pop_II            E_to_I           foi_fxn 
            FALSE             FALSE             FALSE              TRUE 
 get_vertInfo_fxn            I_to_R          j_in_fxn         j_out_fxn 
            FALSE             FALSE             FALSE             FALSE 
         l_ji_fxn net_neighbors_fxn       seed_nd_fxn   sigma_graph_fxn 
            FALSE             FALSE             FALSE             FALSE 
          sim_fxn    sim_lapply_fxn       sim_par_fxn sim_parlapply_fxn 
            FALSE             FALSE             FALSE             FALSE 
     start_TS_fxn            S_to_E 
            FALSE             FALSE 
</pre>
So it is only foi_fxn().
So we make a copy of this in l_ji_fxn_named_vector.r and modify it.
The original version of this function creates the data.frame l_in_node with the code
<pre>
    l_in_node = data.frame(name = vert_info$name,
                           l_in_node = l_in_node_val,
                           stringsAsFactors = FALSE)
</pre> 
So we just change this to 
<pre>
 l_in_node = structure(l_in_node_val, names = vert_info$name)
</pre>
or
<pre>
l_in_node =  (vert_info$b_by_n * (comp1_i + comp2_i))/vert_info$sigma_by_tau_p1
names(l_in_node) = vert_info$name
</pre>

We also have to change one other reference in that function from l_in_node$l_in_node to l_in_node
<p>
So let's source this file in to override the original function definitions and run our simulation again
<pre>
source("l_ji_fxn_named_vector.r")
Rprof("prof")
tm.named_vector = system.time(sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out))
Rprof(NULL)
</pre>
Now the time goes to 10.7, compared to the original 15.3. (Again, we really should re-time both under the same circumstances.)
</p>

<p>
<b>Before we get excited, we really need to check that the results are the same as the original!</b>

<p>
The profiling results below show the % of time match() is taking is decreasing. 
<pre>
summaryRprof("prof")$by.self
                self.time self.pct total.time total.pct
"match"              3.60    33.40       4.74     43.97
"FUN"                2.84    26.35      10.76     99.81
"%in%"               0.64     5.94       5.30     49.17
"[[.data.frame"      0.60     5.57       2.12     19.67
"[["                 0.58     5.38       2.70     25.05
"$"                  0.56     5.19       3.48     32.28
"rbinom"             0.34     3.15       0.34      3.15
"<Anonymous>"        0.28     2.60       0.52      4.82
"lapply"             0.26     2.41      10.76     99.81
"$.data.frame"       0.22     2.04       2.92     27.09
"sys.call"           0.18     1.67       0.18      1.67
"names"              0.16     1.48       0.16      1.48
".subset2"           0.10     0.93       0.10      0.93
"mapply"             0.08     0.74       0.20      1.86
"sum"                0.08     0.74       0.08      0.74
"all"                0.06     0.56       0.06      0.56
"is.matrix"          0.06     0.56       0.06      0.56
"do.call"            0.04     0.37       0.70      6.49
"nargs"              0.04     0.37       0.04      0.37
"foi_fxn"            0.02     0.19       9.92     92.02
"*"                  0.02     0.19       0.02      0.19
"gc"                 0.02     0.19       0.02      0.19
</pre>
<p>
Can we further reduce the time spent in match()?  
We can use the same tools and approach as earlier to count the number of  calls to match
and see where they are coming from (i.e.  the call stack).
Alternatively, we can switch our focus to the next largest consumer of time - FUN.
This is unfortunately named as it is the function argument to sapply()/lapply()/tapply()/mapply()/vapply().
So there could be several functions whose times and percentages are combined together.


<pre>
k = genCallCollector2()
kol = k$collect
trace(match, quote(kol("match")), print = FALSE)
trace(`%in%`, quote(kol("%in%")), print = FALSE)
trace(`[[.data.frame`, quote(kol("[[.data.frame")), print = FALSE)
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
calls = k$ans()
sapply(calls, length)
[[.data.frame          %in%         match 
       432778        502078        502132 
</pre>
So we have eliminated approximately 200K calls to match() (but we have replaced them with named subsetting but this is very fast and doesn't show up in the profiling.).

<p>
<pre>
m = calls$match
foo = lapply(m, function(x) as.character(sapply(x, `[[`, 1)))
bar = sapply(foo, function(x) paste(x[1:(length(x) - 5)], collapse = "->"))
                                                     sim_fxn->lapply->FUN->foi_fxn->structure->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                      54 
                                                                                                 sim_fxn->lapply->FUN->foi_fxn->structure->`%in%`->match 
                                                                                                                                                      54 
                                                                                                         sim_fxn->lapply->FUN->foi_fxn->structure->match 
                                                                                                                                                      54 
                                          sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.character->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                                      56 
                                                        sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match 
                                                                                                                                                      56 
            sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match->mode->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                                      56 
                          sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.character->deparse->`%in%`->match->mode->deparse->`%in%`->match 
                                                                                                                                                      56 
                                                                 sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.character->`%in%`->match 
                                                                                                                                                      56 
                              sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                                      56 
                                            sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->`%in%`->match 
                                                                                                                                                      56 
sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->`%in%`->match->mode->deparse->.deparseOpts->`%in%`->match 
                                                                                                                                                      56 
              sim_fxn->lapply->FUN->data.frame->as.data.frame->as.data.frame.numeric->force->paste->deparse->`%in%`->match->mode->deparse->`%in%`->match 
                                                                                                                                                      56 
                                                             sim_fxn->lapply->FUN->data.frame->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                      56 
                                                        sim_fxn->lapply->FUN->do.call->lapply->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                     112 
                                                                 sim_fxn->lapply->FUN->mapply->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                     112 
                                                                sim_fxn->lapply->FUN->foi_fxn->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                     216 
                                                                         sim_fxn->lapply->FUN->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                     336 
                                                                                               sim_fxn->lapply->FUN->foi_fxn->lapply->FUN->`%in%`->match 
                                                                                                                                                   68742 
                                    sim_fxn->lapply->FUN->foi_fxn->lapply->FUN->`%in%`->match->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                  138024 
                                                   sim_fxn->lapply->FUN->foi_fxn->lapply->FUN->`$`->`$.data.frame`->`[[`->`[[.data.frame`->`%in%`->match 
                                                                                                                                                  293868 
</pre>
We still see direct calls to "%in%" in <code>sim_fxn->lapply->FUN->foi_fxn->lapply->FUN->`%in%`->match</code>.
These come from the other call to lapply() in foi_fxn
<pre>
comp2_i = lapply(comp2_sub, comp2_i_fxn, vert_info)
</pre>
The function comp2_i_fxn is defined has
<pre>
function(comp, vert_info){
    I = vert_info$I[ vert_info$name %in% comp$name ]
    df = I * comp$comp2_sub
    df = sum(df, na.rm = TRUE)
    return(df)
}
</pre>
and we see the %in% in the first line of the body.
So we want to consider if we can do the same thing as we did with l_ji_fxn, i.e. use match() or named vectors.
<b>How did we miss this in the first exploration of %in%</b>

<p>
Let's clean up after ourselves. There are a lot of large objects from the trace().
<pre>
sz = sapply(ls(), function(x) object.size(get(x, globalenv())))
sort(sz)
rm(m, k, kol, sims)

</pre>

<p>
We'll debug the function foi_fxn() to understand the inputs to comp2_i_fxn().
<pre>
debug(foi_fxn)
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
 ...
Browse[2]> class(vert_info)
[1] "data.frame"
Browse[2]> dim(vert_info)
[1] 1273    6
Browse[2]> names(vert_info)
[1] "name"            "eff_pop"         "sigma_by_tau"    "b_by_n"         
[5] "sigma_by_tau_p1" "I"              
Browse[2]>  class(comp2_sub)
[1] "list"
Browse[2]> length(comp2_sub)
[1] 1273
Browse[2]> table(sapply(comp2_sub, class))
data.frame 
      1273 
table(sapply(comp2_sub, ncol))
   0    2 
  10 1263 
table(unlist(sapply(comp2_sub, names)))

comp2_sub      name 
     1263      1263 
summary(unlist(sapply(comp2_sub, nrow)))
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   2.000   3.000   4.239   5.000  59.000 
</pre>
comp2_sub is a list of data.frames, each with 2 columns, or none.

<p>
If we structure vert_info that is passed from foi_fxn() to each call to comp2_i_fxn, we may be able to use named matching.
comp2_i_fxn() is defined as
<pre>
comp2_i_fxn = function(comp, vert_info){
    I = vert_info$I[ vert_info$name %in% comp$name ]
    df = I * comp$comp2_sub
    df = sum(df, na.rm = TRUE)
    return(df)
}
</pre>
It only uses the I and name columns in the vert_info. So again, we can used a named numeric vector.
We can change this to 
<pre>
comp2_i_fxn = function(comp, vI)
{
    df = vI[comp$name] * comp$comp2_sub
    df = sum(df, na.rm = TRUE)
    return(df)
}
</pre>
So we change the lapply() in foi_fxn() to provide the necessary named vector.
This change leads to the line
<pre>
comp2_i = lapply(comp2_sub, comp2_i_fxn, structure(vert_info$I, names = vert_info$name))
</pre>
We also probably do not need to create the I column in vert_info. There is overhead with that to ensure it has the same length as the other
columns in the data.frame, etc.  <b>We need to remember to revisit this, although it probably is not a significant time sink at run-time.</b>
<p>


When we run the simulation with this new code, we see a long pause before the simulation progress bar appears.
And when we look at the profiling information, gc() is the dominant function. This is garbage collection.
This means that we have too many big objects in our work space.  It could be our code is generating large objects,
but we haven't seen this earlier. Or did we when we saw an increase in the run-time.
In these situations, we clear out the objects. But it can also be useful and preferable to restart the R session.
So we'll do this.
<pre>
load("SessionState.rda")
source("simulation-fxns.r-orig")
source("l_ji_fxn_named_vector2.r")
Rprof("prof")
tm.named_vector2 = system.time(sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out))
Rprof(NULL)
</pre>
The time is now down to 7.895 seconds - a non-trivial improvement from 10.7 seconds.

<pre>
summaryRprof("prof")$by.self
                  self.time self.pct total.time total.pct
"FUN"                  4.56    57.72       7.88     99.75
"[[.data.frame"        0.64     8.10       1.94     24.56
"match"                0.42     5.32       0.72      9.11
"<Anonymous>"          0.40     5.06       0.64      8.10
"rbinom"               0.30     3.80       0.30      3.80
"$"                    0.24     3.04       2.52     31.90
"sys.call"             0.22     2.78       0.22      2.78
"[["                   0.20     2.53       2.14     27.09
"$.data.frame"         0.14     1.77       2.28     28.86
"%in%"                 0.12     1.52       0.84     10.63
".subset2"             0.12     1.52       0.12      1.52
"mapply"               0.10     1.27       0.28      3.54
"lapply"               0.08     1.01       7.88     99.75
"*"                    0.08     1.01       0.08      1.01
"names"                0.08     1.01       0.08      1.01
"do.call"              0.04     0.51       0.42      5.32
"all"                  0.04     0.51       0.04      0.51
"as.list.default"      0.04     0.51       0.04      0.51
"sum"                  0.04     0.51       0.04      0.51
"as.data.frame"        0.02     0.25       0.02      0.25
"gc"                   0.02     0.25       0.02      0.25
</pre>
matc() is now down to 5%. 
So now the big time sink is our own FUN in the calls to lapply().
As we mentioned, a deficiency of the profiling  mechanism is we cannot immediately distinguish between how long each of these take.
Before we focus on this, let's look at [[.data.frame.

<p>
These are related to direct calls of the form df[["varName"]], df[[index] and also df$varName.
There are only 8 functions in our simulation - 
and we know what each of these calls:
<pre>
e = new.env()
source("simulation-fxns.r-orig", e)
source("l_ji_fxn_named_vector2.r", e)
library(codetools)
funs = lapply(ls(e), function(f) findGlobals(get(f, e)))
names(funs) = ls(e)
tmp = whatCalls("sim_fxn", , funs,  TRUE)
simFuns = unlist(tmp)
funs[simFuns]
</pre>
<pre>
w = sapply(funs[simFuns], function(x) c("$", "[[") %in% x)
apply(w, 1, which)
</pre>
<pre>
sim_lapply_fxn        foi_fxn    comp2_i_fxn       l_ji_fxn 
             2              4              5              6 

[[2]]
foi_fxn 
      4 
</pre>


We should find out how often these  8 functions are called.
<pre>
ctr = genCounter()
for(i in simFuns) 
  trace(i, substitute(ctr(i), list(i = i)), print = FALSE)
</pre>

<pre>
sims = sim_fxn(nsims, nsteps, start_TS, vert_list, exit_latent, exit_inf, j_out)
environment(ctr)$ans
       sim_fxn sim_lapply_fxn         S_to_E         E_to_I         I_to_R        foi_fxn    comp2_i_fxn       l_ji_fxn 
             1              2          71288          71288          71288             54          68742          68742 
</pre>
So for the $ function/operator, we want to loo at comp2_i_fxn and l_ji_fxn.
For the [[ operator, there are only 54 calls to foi_fxn and so this is not a big issue.
<p>



<h2>Binomial Sampling</h2>
In the most recent profiling, rbinom was identified as being a function that consumed some time, but small - about 4%.
When we look at the functions that call rbinom(), these are S_to_E, E_to_I and I_to_R.
If we look at these, we see that these all generate a single binomial value.
We want to vectorize these. 
These are called in sim_lapply_fxn.  We can check this with 
<pre>
g[, c("S_to_E", "E_to_I", "I_to_R")]
</pre>
where g is defined in WhatCallsWhat.xml

<p>
The calls to rbinom in sim_lapply_fxn are performed in each step of the simulation with
<pre>
E = mapply(S_to_E, prev_TS$S, prev_TS$foi)
I = do.call(rbind, lapply(prev_TS$E, E_to_I, exit_latent))
R = do.call(rbind, lapply(prev_TS$I, I_to_R, exit_inf))
</pre>
In all of these cases, we loop over each binomial size one at a time and generate a value.
The probabilities are specified as second fixed argument. 
If you know a lesser known property of the random generation functions, you will know that
we can vectorize these calls rather than use m/sapply().
In other words, rather than generating one value in each call, we can generate all values
in a single call for each of the E, I, and R steps.
Specifically, instead of 
<pre>
lapply(prev_TS$E, E_to_I, exit_latent)
</pre>
we can call 
<pre>
rbinom(length(prev_TS$E), prev_TS$E, exit_latent)
</pre>
This generates length(prev_TS$E) values and each one comes from a binomial 
random variable with size = prev_TS$E[i] and probability exit_latent.

<p>
When both the size and the probabilities change per row/record, we can still use
the vectorized version of rbinom. We simply specify vectors for size and probability.
<p>
So we can replace the code in sim_lapply_fxn
<pre>
 E = mapply(S_to_E, prev_TS$S, prev_TS$foi)
 I = do.call(rbind, lapply(prev_TS$E, E_to_I, exit_latent))
 R = do.call(rbind, lapply(prev_TS$I, I_to_R, exit_inf))
</pre>
with 
<pre>
 n = nrow(prev_TS)    
 E = rbinom(n, prev_TS$S, prev_TS$foi)
 I = rbinom(n, prev_TS$E, exit_latent)
 R = rbinom(n, prev_TS$I, exit_inf)        
</pre>
You should verify that this gives the same statistical results. See rbinom.R for some suggestions as to how to do this.
<p>
Note that changing this code does mean we may not get identical results even when we set the seed.
We may be changing the order in which we generate random numbers.

<h2>Assignments and return()</h2>
Several of the functions finish with 
<pre>
ans = foo(x, y)
return(ans)
</pre>
For example, comp2_i_fxn
<pre>
comp2_i_fxn =
function(comp, vI)
{
    df = vI[comp$name] * comp$comp2_sub
    df = sum(df, na.rm = TRUE)
    return(df)
}
</pre>
I prefer not to have the explicit return() but just return ans.
And also, the assignment in the penultimate line is unnecessary. So this could  be simplified to 
<pre>
comp2_i_fxn =
function(comp, vI)
{
    df = vI[comp$name] * comp$comp2_sub
    sum(df, na.rm = TRUE)
 }
</pre>

We can find which functions have this idiom with 
<pre>
source("assignReturn.R")
sapply(simFuns, isAssignReturn)
       sim_fxn sim_lapply_fxn         E_to_I        foi_fxn    comp2_i_fxn       l_ji_fxn         I_to_R         S_to_E 
          TRUE          FALSE           TRUE           TRUE           TRUE           TRUE           TRUE           TRUE 
</pre>
This is all but one - sim_lapply_fxn. This is a for loop and a cat() before the end. 


<h2 id="Summary">Summary of Changes</h2>

<ul>

<li>

<li> Never use global variables.
<li> Pick the best data structure, i.e. named numeric vector rather than a data.frame with names in one column and values in another. Don't default to a data.frame unless there is a good reason.  data.frame's are more expensive that simple lists (checking lengths, rownames are unique, ...).
  So if you know the elements have the same length, you can avoid some overhead.
<li> Use named subsetting <code>x[names]</code> or match() rather than <code>names %in% table</code> if the number of things to match is much smaller than the set of possible matches.
<li> Use vectorization as much as possible, including vectorization in parameters/arguments to functions such as <code>rbinom(n, sizeVector, probVector)</code>. This samples many distributions in one call.

<li> Do computations once and pass results to functions/code that use them to avoid recomputing them.
<li> Avoid unnecessary computations, e.g. do.call(rbind, x) when the elements of the list are
  scalars and could have been collapsed into a vector directly with vapply.
<li> In a function, don't assign a value to a variable and then in the next line return the variable
<pre>
 a = function(I, p){
    R = rbinom(n = 1, size = I, prob = p)
    return(R)
 }
</pre>
versus
<pre>
 a = function(I, p){
    rbinom(n = 1, size = I, prob = p)
 }
</pre>
Shorter and avoids the overhead of assigning the variable (small cost but a cost).
</ul>

</body>
</html>
